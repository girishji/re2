# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Capturing indices to group names
#'
#' Return a map (named character vector) from capturing indices 
#'   to names of groups (if named). The mapping has no
#'   entries for unnamed groups. If parameter is a vector of pattern
#'   strings, then a list of mappings is returned.
#'
#' @param pattern Character string containing a regular expression,
#'    or a precompiled regular expression (see \code{\link{re2_re2}}).
#'    Or, a vector of such pattern strings.
#'
#' @return A named character vector reflecting the mapping from
#'   capturing indices to names. Or, a list of mappings if parameter
#'   is a vector.
#'
#' @examples
#' cgn <- re2_capturing_group_names("((abc)(?P<G2>)|((e+)(?P<G2>.*)(?P<G1>u+)))")
#' # 1st group is the outer paranthesis, 2nd groups is the unamed (abc), and so on.
#' stopifnot(cgn["3"] == "G2")
#' stopifnot(cgn["6"] == "G2")
#' stopifnot(cgn["7"] == "G1")
#' stopifnot(length(cgn) == 3)
#' stopifnot(is.na(cgn["1"]))
#'
#' # Same as above, except using compiled pattern:
#' re2p <- re2_re2("((abc)(?P<G2>)|((e+)(?P<G2>.*)(?P<G1>u+)))")
#' cgn <- re2_capturing_group_names(re2p)
#'
#' # If input is a vector of patterns, a list is returned:
#' cgn <- re2_capturing_group_names(c("bar", "(foo)(?P<Gr1>)"))
#' stopifnot(mode(cgn) == "list")
#'
#' @seealso \code{\link{re2_named_capturing_groups}},
#'   \code{\link{re2_number_of_capturing_groups}},
#'   \code{\link{re2_re2}}, \code{\link{re2_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_global_replace}},
#'   \code{\link{re2_extract}}.
re2_capturing_group_names <- function(pattern) {
    .Call(`_re2_re2_capturing_group_names`, pattern)
}

#' Check suitability of rewrite string
#'
#' Check if a rewrite string is suitable for use with a regular expression.
#'
#' Check that the given rewrite string is suitable for use with a
#' regular expression. It checks that:
#' \itemize{
#'   \item The regular expression has enough parenthesized subexpressions
#'     to satisfy all of the \\N tokens in rewrite
#'   \item The rewrite string doesn't have any syntax errors. E.g.,
#'     '\\' followed by anything other than a digit or '\\'.
#' }
#' A TRUE return value guarantees that \code{\link{re2_replace}} and
#'   \code{\link{re2_extract}} won't fail because of a bad rewrite
#'   string.
#'
#' @inheritParams re2_replace
#' @param \dots If \verb{verbose=TRUE} or \verb{v=T}, error string is
#'   returned (in case of error) along with logical TRUE/FALSE. In addition,
#'   options to \code{\link{re2_re2}} are also applicable.
#'
#' @return TRUE/FALSE or a vector of logical values. With verbose
#'   option error strings are also returned in case of error.
#'
#' @usage re2_check_rewrite_string(pattern, rewrite, ...)
#'
#' @examples
#' stopifnot(re2_check_rewrite_string("abc", "foo"));
#' stopifnot(!re2_check_rewrite_string("abc", "foo\\"));
#' stopifnot(re2_check_rewrite_string("abc", "foo\\0bar"));
#' 
#' stopifnot(re2_check_rewrite_string("a(b)c", "foo"));
#' stopifnot(re2_check_rewrite_string("a(b)c", "foo\\0bar"));
#' stopifnot(re2_check_rewrite_string("a(b)c", "foo\\1bar"));
#' stopifnot(!re2_check_rewrite_string("a(b)c", "foo\\2bar"));
#' stopifnot(re2_check_rewrite_string("a(b)c", "f\\\\2o\\1o"));
#' 
#' stopifnot(re2_check_rewrite_string("a(b)(c)", "foo\\12"));
#' stopifnot(re2_check_rewrite_string("a(b)(c)", "f\\2o\\1o"));
#' stopifnot(!re2_check_rewrite_string("a(b)(c)", "f\\oo\\1"));
#' 
re2_check_rewrite_string <- function(pattern, rewrite, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_check_rewrite_string`, pattern, rewrite, more_options)
}

#' Extract with substitutions
#'
#' @description
#' Like \code{\link{re2_replace}}, except that if the pattern matches,
#'   "rewrite" string is returned with substitutions. The
#'   non-matching portions of "text" are ignored.
#'
#' Difference between \code{re2_extract} and \code{\link{re2_replace}}:
#' \preformatted{
#' > re2_extract("bunny@wunnies.pl", "(.*)@([^.]*)", "\\2!\\1")
#' [1] "wunnies!bunny"
#' 
#' > re2_replace("bunny@wunnies.pl", "(.*)@([^.]*)", "\\2!\\1")
#' [1] "wunnies!bunny.pl"
#' }
#' "\\1" and "\\2" are names of capturing subgroups.
#'
#' @param text A character string or a character vector where
#'   extractions are sought.
#' @inheritParams re2_replace
#'
#' @param \dots The options are (defaults in parentheses):
#'
#' \tabular{lll}{
#'   \verb{logical} \tab (\verb{FALSE}) If TRUE, returns a logical
#'                         result of TRUE iff a match occurred and 
#'                         the extraction happened successfully.
#'                         FALSE otherwise. \cr
#'   \verb{verbose} \tab (\verb{FALSE}) If TRUE, character string
#'                         or vector with extractions is returned
#'                         along with logical result.\cr
#'   \verb{l} \tab (\verb{FALSE}) Same as \verb{logical} above.\cr
#'   \verb{v} \tab (\verb{FALSE}) Same as \verb{verbose} above.\cr
#' }
#' In addition, options under "RE2 Options" section below are also
#'   applicable when \verb{pattern} is given as a character string.
#'    If regexp pattern is precompiled, then options given to
#'   \code{\link{re2_re2}} take precedence.
#'
#' @inheritSection re2_re2 RE2 Options
#'
#' @return A character string or character vector with extractions.
#'   A logical TRUE/FALSE vector may also be returned depending on the
#'   options.
#'
#' @usage re2_extract(text, pattern, rewrite, ...)
#'
#' @examples
#' # Returns extracted string with substitutions
#' stopifnot(re2_extract("bunny@wunnies.pl",
#'                       "(.*)@([^.]*)",
#'                       "\\2!\\1")
#'           == "wunnies!bunny")
#'
#' # Case insensitive
#' stopifnot(re2_extract("Bunny@wunnies.pl",
#'                       "(b.*)@([^.]*)",
#'                       "\\2!\\1",
#'                       case_sensitive=FALSE)
#'           == "wunnies!Bunny")
#' 
#' # Max submatch too large (1 match group, 2 submatches needed)
#' stopifnot(!re2_extract("foo", "f(o+)", "\\1\\2", logical=TRUE))
#' 
#' # No match, nothing is extracted
#' stopifnot(re2_extract("baz", "bar", "'\\0'") == "")
#' 
#' # When match fails, logical result is a FALSE
#' stopifnot(!re2_extract("baz", "bar", "'\\0'", logical=TRUE))
#' 
#' # A vector parameter
#' stopifnot(re2_extract(c("Bunny@wunnies.pl", "cargo@cult.org"),
#'                       "(.*)@([^.]*)", "\\2!\\1")
#'           == c("wunnies!Bunny", "cult!cargo"))
#'
#' @inheritSection re2_re2 Regexp Syntax
#'
#' @seealso \code{\link{re2_re2}}, \link{re2_syntax},
#'   \code{\link{re2_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_global_replace}}.
re2_extract <- function(text, pattern, rewrite, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_extract`, text, pattern, rewrite, more_options)
}

#' Retrieve options
#'
#' \code{re2_get_options} returns a list of all options from a
#'   RE2 object (internal representation of compiled regexp).
#'
#' @param re2ptr The value obtained from call to \code{\link{re2_re2}}.
#' @return A list of option value mappings.
#'
#' @seealso \code{\link{re2_re2}}.
#'
re2_get_options <- function(re2ptr) {
    .Call(`_re2_re2_get_options`, re2ptr)
}

#' Global replace
#'
#' @description
#' Replace successive non-overlapping occurrences of "pattern" in
#'   "text" with "rewrite" string.
#' \preformatted{
#'   re2_global_replace("yabba dabba doo", "b+", "d")
#' }
#' will result in "yada dada doo".
#' Replacements are not subject to re-matching.
#'
#' Because \verb{re2_global_replace} only replaces non-overlapping matches,
#'   replacing "ana" within "banana" makes only one replacement, not
#'   two.
#'
#' @inheritParams re2_replace
#'
#' @param \dots The options are (defaults in parentheses):
#' \tabular{lll}{
#'   \verb{count} \tab (\verb{FALSE}) If TRUE, returns the 
#'                       number of replacements made. \cr
#'   \verb{verbose} \tab (\verb{FALSE}) If TRUE, character string
#'                         or vector with replacements is returned
#'                         along with number of replacements made.\cr
#'   \verb{c} \tab (\verb{FALSE}) Same as \verb{logical} above.\cr
#'   \verb{v} \tab (\verb{FALSE}) Same as \verb{verbose} above.\cr
#' }
#' In addition, options under "RE2 Options" section below are also
#'   applicable when \verb{pattern} is given as a character string.
#'   If regexp pattern is precompiled, then options given to
#'   \code{\link{re2_re2}} take precedence.
#'
#' @inheritSection re2_re2 RE2 Options
#'
#' @return A character string or vector with replacements. An integer
#'   count of number of replacements made may also be returned
#'   depending on the options.
#'
#' @usage re2_global_replace(text, pattern, rewrite, ...)
#'
#' @examples
#' s <-  c("yabba dabba doo", "famab")
#' res <- re2_global_replace(s, "b+", "d")
#' expected <- c("yada dada doo", "famad")
#' stopifnot(res == expected)
#' 
#' re <- "(qu|[b-df-hj-np-tv-z]*)([a-z]+)"
#' rewrite <- "\\2\\1ay"
#' s <- "the quick brown fox jumps over the lazy dogs."
#' expected <- "ethay ickquay ownbray oxfay umpsjay overay ethay azylay ogsday."
#' res <- re2_global_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "\\w+"
#' rewrite <- "\\0-NOSPAM"
#' s <- "abcd.efghi@google.com"
#' expected <- "abcd-NOSPAM.efghi-NOSPAM@google-NOSPAM.com-NOSPAM"
#' res <- re2_global_replace(s, re, rewrite)
#' stopifnot(res == expected)
#'  
#' re <- "a.*a"
#' rewrite <- "(\\0)"
#' s <- "aba\naba"
#' expected <- "(aba)\n(aba)"
#' res <- re2_global_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "b"
#' rewrite <- "bb"
#' s <- "ababababab"
#' expected <- "abbabbabbabbabb"
#' res <- re2_global_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "b+"
#' rewrite <- "bb"
#' s <- "bbbbbb"
#' expected <- "bb"
#' res <- re2_global_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "b*"
#' rewrite <- "bb"
#' s <- c("bbbbbb", "aaaaa")
#' expected <- c("bb", "bbabbabbabbabbabb") 
#' res <- re2_global_replace(s, re, rewrite)
#' stopifnot(res == expected)
#'
#' @inheritSection re2_re2 Regexp Syntax
#'
#' @seealso \code{\link{re2_re2}}, \link{re2_syntax},
#'   \code{\link{re2_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_extract}}.
re2_global_replace <- function(text, pattern, rewrite, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_global_replace`, text, pattern, rewrite, more_options)
}

#' Matching and substring extraction
#'
#' @description
#' Match against text using a regular expression and extract matched
#'   substrings.
#'
#' I.e., matching regexp "(foo)|(bar)baz" on "barbazbla" will return
#'   submatches '.0' = "barbaz", '.1' = NA, and '.2' = "bar". '.0' is
#'   the entire matching text. '.1' is the first group,
#'   and so on. Groups can also be named.
#'
#' @param text A character string or a character vector where
#'   match is sought.
#' @param pattern Character string containing a regular expression,
#'    or a precompiled regular expression (see \code{\link{re2_re2}}).
#' @param \dots The options are (defaults in parentheses):
#'
#' \tabular{lll}{
#'   \verb{logical} \tab (\verb{FALSE}) If TRUE, returns a logical
#'                         result of TRUE if match is found.
#'                         FALSE if not. Here, nsubmatch = 0.\cr
#'   \verb{l} \tab (\verb{FALSE}) Same as \verb{logical} above.\cr
#'   \verb{startpos} \tab (\verb{0}) Text offset to start matching.\cr
#'   \verb{endpos} \tab (length of \verb{text}) Text offset to stop matching.\cr
#'   \verb{nsubmatch} \tab ('number of capturing groups' plus 1)
#'                           Number of submatch entries returned.
#'                           Don't ask for more match information than you
#'                           will use: runs much faster with nsubmatch == 1
#'                           than nsubmatch > 1, and runs even faster if
#'                           nsubmatch == 0. Doesn't make sense to use
#'                           nsubmatch > 1 + \code{re2_number_of_capturing_groups},
#'                           but will be handled correctly.\cr
#'   \verb{re_anchor} \tab (\verb{"UNANCHORED"})
#'                          "UNANCHORED" - No anchoring
#'                          "ANCHOR_START" - Anchor at start only
#'                          "ANCHOR_BOTH" - Anchor at start and end. \cr
#'   \verb{verbose} \tab (\verb{FALSE}) If TRUE, character
#'                         matrix with map of group names and matching
#'                         text is returned along with logical result.\cr
#'   \verb{v} \tab (\verb{FALSE}) Same as \verb{verbose} above.\cr
#' }
#' In addition, options under "RE2 Options" section below are also
#'   applicable when \verb{pattern} is given as a character string.
#'   If regexp pattern is precompiled, then options given to
#'   \code{\link{re2_re2}} take precedence.
#'
#' @inheritSection re2_re2 RE2 Options
#'
#' @return A character matrix with map of group names and matching
#'   text. Column '.0' is the entire matching text. A logical
#'   TRUE/FALSE vector may also be returned depending on the
#'   options. TRUE if match is found. FALSE if not.
#'
#' @usage re2_match(text, pattern, ...)
#'
#' @inheritSection re2_re2 Regexp Syntax
#'
#' @examples
#' 
#' ## Matching with substring extraction
#' s <- c("barbazbla", "foobar", "this is a test")
#' pat <- "(foo)|(?P<TestGroup>bar)baz"
#' re2_match(s, pat)
#' # > re2_match(s, pat)
#' #      .0       .1    TestGroup
#' # [1,] "barbaz" NA    "bar"
#' # [2,] "foo"    "foo" NA
#' # [3,] NA       NA    NA
#'
#' ## Matching with logical result
#' re2_match(s, pat, l=TRUE)
#' # > re2_match(s, pat, l=TRUE)
#' # [1]  TRUE  TRUE FALSE
#' 
#' stopifnot(is.matrix(re2_match(s, pat)))
#' r <- re2_match(s, pat)
#' stopifnot(colnames(r) == c(".0", ".1", "TestGroup"))
#' stopifnot(nrow(r) == 3, ncol(r) == 3)
#' stopifnot(r[2, 1:2] == c("foo", "foo"))
#' 
#' ## Compile regexp and use logical result
#' re <- re2_re2("(foo)|(?P<TestGroup>bar)baz")
#' stopifnot(re2_match(s, re, l=TRUE) == c(TRUE, TRUE, FALSE))
#' 
#' ## Full anchored match
#' 
#' # Successful full match
#' stopifnot(re2_match("hello", "h.*o",
#'           re_anchor="ANCHOR_BOTH", l=TRUE))
#' 
#' # Unuccessful full match 
#' stopifnot(!re2_match("hello", "e",
#'           re_anchor="ANCHOR_BOTH", l=TRUE))
#' 
#' ## UTF-8 and matching interface:
#' 
#' # By default, the pattern and input text are interpreted as UTF-8.
#' # The Latin1 option causes them to be interpreted as Latin-1.
#' x <- "fa\xE7ile"
#' Encoding(x) <- "latin1"
#' x
#' stopifnot(!re2_match(x, "fa\xE7", l=TRUE))
#' stopifnot(re2_match(x, "fa\xE7", l=TRUE, encoding="Latin1"))
#' 
#' ## Use of nsubmatch (ask for less):
#' 
#' re2_match("ruby:1234", "(\\w+):(\\d+)", nsubmatch=1)
#' # > re2_match("ruby:1234", "(\\w+):(\\d+)", nsubmatch=1)
#' #      .0
#' # [1,] "ruby:1234"
#' stopifnot(length(re2_match("ruby:1234", "(\\w+):(\\d+)",
#'                  nsubmatch=1)) == 1)
#'      
#' @seealso \code{\link{re2_match_l}}, \code{\link{re2_re2}},
#'   \link{re2_syntax},
#'   \code{\link{re2_global_replace}},
#'   \code{\link{re2_replace}}, \code{\link{re2_extract}}.
#'
re2_match <- function(text, pattern, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_match`, text, pattern, more_options)
}

#' Matching (searching for pattern)
#'
#' @description
#' Match against text using a regular expression.
#'
#' I.e., matching regexp "(foo)|(bar)baz" on "barbazbla" will return
#' TRUE.
#'
#' @inheritParams re2_match
#'
#' @inheritSection re2_re2 RE2 Options
#'
#' @return A logical vector. TRUE if match is found, FALSE if not.
#'
#' @usage re2_match_l(text, pattern, ...)
#'
#' @inheritSection re2_re2 Regexp Syntax
#'
#' @examples
#' 
#' ## Matching against a character vector
#' s <- c("barbazbla", "foobar", "this is a test")
#' pat <- "(foo)|(?P<TestGroup>bar)baz"
#' re2_match_l(s, pat)
#' # > re2_match_l(s, pat)
#' # [1]  TRUE  TRUE FALSE
#' 
#' ## Use precompiled regexp
#' re <- re2_re2("(foo)|(?P<TestGroup>bar)baz")
#' stopifnot(re2_match_l(s, re) == c(TRUE, TRUE, FALSE))
#' 
#' ## UTF-8 and matching interface:
#' # By default, the pattern and input text are interpreted as UTF-8.
#' # The Latin1 option causes them to be interpreted as Latin-1.
#' x <- "fa\xE7ile"
#' Encoding(x) <- "latin1"
#' x
#' stopifnot(!re2_match_l(x, "fa\xE7"))
#' stopifnot(re2_match_l(x, "fa\xE7", encoding="Latin1"))
#'      
#' @seealso \code{\link{re2_match}}, \code{\link{re2_re2}},
#'   \link{re2_syntax},
#'   \code{\link{re2_global_replace}},
#'   \code{\link{re2_replace}}, \code{\link{re2_extract}}.
#'
re2_match_l <- function(text, pattern, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_match_l`, text, pattern, more_options)
}

#' Maximum submatch
#'
#' Returns the maximum submatch needed for rewrite.
#'   For \code{\link{re2_replace}} and \code{\link{re2_extract}} to be
#'   successful, the number
#'   of matching groups (submatch) has to be at least a many as the
#'   maximum group number mentioned in the rewrite string. The latter
#'   is returned by this function.
#'   
#' @param rewrite Character string containing rewrite instructions.
#' @return A non-negative integer indicating the maximum submatch.
#'
#' @examples
#' stopifnot(re2_max_submatch("foo \\2,\\1") == 2)
#' stopifnot(re2_max_submatch("bar \\2: \\5") == 5)
#' stopifnot(re2_max_submatch(c("bar \\2: \\5", "\\1 \\9")) == c(5, 9))
#'
#' @seealso \code{\link{re2_number_of_capturing_groups}}, \code{\link{re2_replace}},
#'   \code{\link{re2_global_replace}}, \code{\link{re2_extract}}.
re2_max_submatch <- function(rewrite) {
    .Call(`_re2_re2_max_submatch`, rewrite)
}

#' Group names to capturing indices
#'
#' Return a map from names to capturing indices.
#' The map records the index of the leftmost group
#' with the given name.
#'
#' @inheritParams re2_capturing_group_names
#'
#' @return A named character vector reflecting the mapping from
#'   group names to capturing indices. Or, a list of mappings
#'   if parameter is a vector.
#'
#' @examples
#' res <- re2_named_capturing_groups("(hello world)")
#' stopifnot(is.na(res))
#' 
#' res <- re2_named_capturing_groups("directions from (?P<S>.*) to (?P<D>.*)")
#' stopifnot(res["S"] == 1)
#' stopifnot(res["D"] == 2)
#' 
#' s <- "(?P<A>expr(?P<B>expr)(?P<C>expr))((expr)(?P<D>expr))"
#' res <- re2_named_capturing_groups(s)
#' stopifnot(res["A"] == 1)
#' stopifnot(res["B"] == 2)
#' stopifnot(res["C"] == 3)
#' stopifnot(res["D"] == 6)
#'
#' @seealso \code{\link{re2_capturing_group_names}},
#'   \code{\link{re2_number_of_capturing_groups}},
#'   \code{\link{re2_re2}}, \code{\link{re2_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_global_replace}},
#'   \code{\link{re2_extract}}.
re2_named_capturing_groups <- function(pattern) {
    .Call(`_re2_re2_named_capturing_groups`, pattern)
}

#' Number of capturing subpatterns
#'
#' Return the number of capturing subpatterns, or -1 if the
#' regexp wasn't valid on construction.  The overall match ($0)
#' does not count: if the regexp is "(a)(b)", returns 2.
#'
#' @inheritParams re2_capturing_group_names
#'
#' @return Number of capturing groups or -1 on error.
#'
#' @examples
#' s <- "(?P<A>expr(?P<B>expr)(?P<C>expr))((expr)(?P<D>expr))"
#' stopifnot(re2_number_of_capturing_groups(s) == 6)
#' 
#' re2p <- re2_re2("directions from (?P<S>.*) to (?P<D>.*)")
#' stopifnot(re2_number_of_capturing_groups(re2p) == 2)
#'
#' @seealso
#'   \code{\link{re2_named_capturing_groups}},
#'   \code{\link{re2_capturing_group_names}},
#'   \code{\link{re2_re2}}, \code{\link{re2_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_global_replace}},
#'   \code{\link{re2_extract}}.
re2_number_of_capturing_groups <- function(pattern) {
    .Call(`_re2_re2_number_of_capturing_groups`, pattern)
}

#' Range for strings matching a regexp
#'
#' @description
#' Computes range for any strings matching regexp. The min and max can in
#' some cases be arbitrarily precise, so the caller gets to specify the
#' maximum desired length of string returned.
#'
#' Assuming \code{re2_possible_match_range} returns successfully, any
#' string s that is an anchored match for this regexp satisfies
#' \preformatted{  min <= s && s <= max.}
#'
#' Note that \code{re2_possible_match_range} will only consider the first copy of an
#' infinitely repeated element (i.e., any regexp element followed by a '*' or
#' '+' operator). Regexps with "{N}" constructions are not affected, as those
#' do not compile down to infinite repetitions.
#'
#' @inheritParams re2_replace
#' @param maxlen An integer specifying maximum desired length of returned string.
#' @param \dots If \verb{logical=TRUE} or \verb{l=T} is specified, it
#'   returns TRUE if successful and FALSE otherwise.  If
#'   \verb{verbose=TRUE} or \verb{v=T} is given, character vector
#'   (with two strings) is returned with "min" and "max" strings. In
#'   addition, options to \code{\link{re2_re2}} may also applicable.
#'
#' @return A named character vector with "min" and "max" values.
#'   With \verb{verbose} and \verb{logical} options, returns TRUE if
#'   successful and FALSE otherwise.
#'
#' @usage re2_possible_match_range(pattern, maxlen, ...)
#'
#' @examples
#' r <- re2_possible_match_range("abc|def", 10)
#' stopifnot(r["min"] == "abc", r["max"] == "def")
#' 
#' r <- re2_possible_match_range("a(b)(c)[d]", 10)
#' stopifnot(r["min"] == "abcd", r["max"] == "abcd")
#' 
#' r <- re2_possible_match_range("(abc)+", 10)
#' stopifnot(r["min"] == "abc", r["max"] == "abcac")
#' 
#' r <- re2_possible_match_range("(?i)Abcdef", 10)
#' stopifnot(r["min"] == "ABCDEF", r["max"] == "abcdef")
#'
#' @seealso \code{\link{re2_re2}}, \code{\link{re2_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_global_replace}},
#'   \code{\link{re2_extract}}.
re2_possible_match_range <- function(pattern, maxlen, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_possible_match_range`, pattern, maxlen, more_options)
}

#' Escape regexp characters
#'
#' Escapes all potentially meaningful regexp characters in
#' regexp string. The returned string, used as a regular expression,
#' will match exactly the original string.  For example,
#' \preformatted{          1.5-2.0?}
#' may become:
#' \preformatted{          1\.5\-2\.0\?}
#'
#' @param unquoted Character string or vector with regexp.
#'
#' @return Character string or vector with escape characters added.
#'   
re2_quote_meta <- function(unquoted) {
    .Call(`_re2_re2_quote_meta`, unquoted)
}

#' Compile regex pattern
#'
#' \code{re2_re2} compiles a character string containing a regular
#'   expression and returns a pointer to the internal representation.
#'   The returned value can be used (instead of
#'   character string pattern) in \code{\link{re2_match}},
#'   \code{\link{re2_replace}}, \code{\link{re2_global_replace}},
#'   \code{\link{re2_extract}}, etc. for efficiency.
#'
#' @section Regexp Syntax:
#'
#' RE2 regular expression syntax is similar to Perl's with some of
#'   the more complicated things thrown away. In particular,
#'   backreferences and generalized assertions are not available, nor
#'   is \verb{\Z}.
#'
#' See \link{re2_syntax} for the syntax
#'   supported by RE2, and a comparison with PCRE and PERL regexps.
#'
#' For those not familiar with Perl's regular expressions, here are
#'   some examples of the most commonly used extensions:
#' \tabular{lll}{
#'   \verb{"hello (\\w+) world"} \tab -- \tab \\w matches a "word" character. \cr
#'   \verb{"version (\\d+)"}     \tab -- \tab \\d matches a digit. \cr
#'   \verb{"hello\\s+world"}     \tab -- \tab \\s matches any whitespace character. \cr
#'   \verb{"\\b(\\w+)\\b"}       \tab -- \tab \\b matches non-empty string at word boundary. \cr
#'   \verb{"(?i)hello"}        \tab -- \tab (?i) turns on case-insensitive matching. \cr
#'   \verb{"/\\*(.*?)\\*/"}      \tab -- \tab \verb{.*?} matches . minimum no. of times possible.
#' }
#' The double backslashes are needed when writing R string literals.
#' However, they should NOT be used when writing raw string literals:
#' \tabular{lll}{
#'   \verb{r"(hello (\w+) world)"} \tab -- \tab \\w matches a "word" character. \cr
#'   \verb{r"(version (\d+))"}     \tab -- \tab \\d matches a digit. \cr
#'   \verb{r"(hello\s+world)"}     \tab -- \tab \\s matches any whitespace character. \cr
#'   \verb{r"(\b(\w+)\b)"}       \tab -- \tab \\b matches non-empty string at word boundary. \cr
#'   \verb{r"((?i)hello)"}        \tab -- \tab (?i) turns on case-insensitive matching. \cr
#'   \verb{r"(/\*(.*?)\*/)"}      \tab -- \tab \verb{.*?} matches . minimum no. of times possible.
#' }
#' When using UTF-8 encoding, case-insensitive matching will perform
#' simple case folding, not full case folding.
#'
#' @param pattern Character string containing a
#' regular expression.
#'
#' @param \dots Options, as comma separated \verb{option=value}. See "RE2 Options" section below.
#'
#' @section RE2 Options:
#' The options are (defaults in parentheses):
#'
#' \tabular{lll}{
#'   \verb{encoding} \tab (\verb{"UTF8"}) Text and pattern are UTF-8;
#'                                 Otherwise \verb{"Latin1"}.\cr
#'   \verb{posix_syntax} \tab (\verb{FALSE}) Restrict regexps to POSIX egrep syntax.\cr 
#'   \verb{longest_match} \tab (\verb{FALSE}) Search for longest match, not first match.\cr
#'   \verb{max_mem} \tab (see below) Approx. max memory footprint of RE2.\cr
#'   \verb{literal} \tab (\verb{FALSE}) Interpret string as literal, not regexp.\cr
#'   \verb{never_nl} \tab (\verb{FALSE}) Never match \\n, even if it is in regexp.\cr
#'   \verb{dot_nl} \tab (\verb{FALSE}) Dot matches everything including new line.\cr
#'   \verb{never_capture} \tab (\verb{FALSE}) Parse all parens as non-capturing.\cr
#'   \verb{case_sensitive} \tab (\verb{TRUE}) Match is case-sensitive (regexp can 
#'                                      override with (?i) unless in posix_syntax mode).\cr
#' }
#' The following options are only consulted when \verb{posix_syntax=TRUE}.
#' When \verb{posix_syntax=FALSE}, these features are always enabled and
#' cannot be turned off; to perform multi-line matching in that case,
#' begin the regexp with (?m). 
#' \tabular{lll}{
#'   \verb{perl_classes} \tab (\verb{FALSE}) Allow Perl's \verb{\\d \\s \\w \\D \\S \\W}.\cr
#'   \verb{word_boundary} \tab (\verb{FALSE}) Allow Perl's \verb{\\b \\B} (word boundary and not).\cr
#'   \verb{one_line} \tab (\verb{FALSE}) \verb{^} and \verb{$} only match beginning and end of text.\cr
#' }
#' The \verb{max_mem} option controls how much memory can be used
#' to hold the compiled form of the regexp (the Prog) and
#' its cached DFA graphs. Code Search placed limits on the number
#' of Prog instructions and DFA states: 10,000 for both.
#' In RE2, those limits would translate to about 240 KB per Prog
#' and perhaps 2.5 MB per DFA (DFA state sizes vary by regexp; RE2 does a
#' better job of keeping them small than Code Search did).
#' Each RE2 has two Progs (one forward, one reverse), and each Prog
#' can have two DFAs (one first match, one longest match). \cr
#' That makes 4 DFAs: 
#' \tabular{lll}{
#'   forward, first-match   \tab - \tab used for \verb{UNANCHORED} or \verb{ANCHOR_START} 
#'                             searches if \verb{longest_match=FALSE}. \cr
#'   forward, longest-match \tab - \tab used for all \verb{ANCHOR_BOTH} searches,
#'                             and the other two kinds if 
#'                             \verb{longest_match=TRUE}. \cr
#'   reverse, first-match   \tab - \tab never used. \cr
#'   reverse, longest-match \tab - \tab used as second phase for unanchored
#'                                      searches. \cr
#' }
#' The RE2 memory budget is statically divided between the two
#' Progs and then the DFAs: two thirds to the forward Prog
#' and one third to the reverse Prog.  The forward Prog gives half
#' of what it has left over to each of its DFAs.  The reverse Prog
#' gives it all to its longest-match DFA.
#'
#' Once a DFA fills its budget, it flushes its cache and starts over.
#' If this happens too often, RE2 falls back on the NFA implementation.
#' 
#' @return Compiled regular expression.
#'
#' @examples
#' re2p <- re2_re2("hello world")
#' stopifnot(mode(re2p) == "externalptr")
#' 
#' re2p <- re2_re2("Ruby:1234", case_sensitive=FALSE)
#' stopifnot(mode(re2p) == "externalptr")
#'
#' @usage re2_re2(pattern, \dots)
#'
#' @seealso \link{re2_syntax},  \code{\link{re2_replace}}, \code{\link{re2_global_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_extract}}.
re2_re2 <- function(pattern, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_re2`, pattern, more_options)
}

#' Replace the first match
#'
#' @description
#' Replace the first match of "pattern" in "text" with
#'   "rewrite" string. 
#' \preformatted{
#'   re2_replace("yabba dabba doo", "b+", "d")
#' }
#' will result in "yada dabba doo".
#'
#' @param text A character string or a character vector where
#'   replacements are sought.
#'
#' @inheritParams re2_match
#'
#' @param rewrite Rewrite string. Backslash-escaped
#'   digits (\\1 to \\9) can be used to insert text matching
#'   corresponding parenthesized group from the pattern. \\0
#'   refers to the entire matching text.
#'
#' @param \dots The options are (defaults in parentheses):
#'
#' \tabular{lll}{
#'   \verb{logical} \tab (\verb{FALSE}) If TRUE, returns a logical
#'                         result of TRUE if the pattern matches
#'                         and a replacement occurs. FALSE otherwise.\cr
#'   \verb{verbose} \tab (\verb{FALSE}) If TRUE, character string
#'                         or vector with replacements is returned
#'                         along with logical result.\cr
#'   \verb{l} \tab (\verb{FALSE}) Same as \verb{logical} above.\cr
#'   \verb{v} \tab (\verb{FALSE}) Same as \verb{verbose} above.\cr
#' }
#' In addition, options under "RE2 Options" section below are also
#'   applicable when \verb{pattern} is given as a character string.
#'   If regexp pattern is precompiled, then options given to
#'   \code{\link{re2_re2}} take precedence.
#'
#' @inheritSection re2_re2 RE2 Options
#'
#' @return A character string or vector with replacements. A logical
#'   TRUE/FALSE vector may also be returned depending on the
#'   options.
#'
#' @usage re2_replace(text, pattern, rewrite, ...)
#'
#' @inheritSection re2_re2 Regexp Syntax
#'
#' @examples
#' s <-  c("yabba dabba doo", "famab")
#' res <- re2_replace(s, "b+", "d")
#' expected <- c("yada dabba doo", "famad")
#' stopifnot(res == expected)
#' 
#' res <- re2_replace("boris@kremvax.ru",
#'                    "(.*)@([^.]*)", "\\2!\\1")
#' expected <- "kremvax!boris.ru"
#' stopifnot(res == expected)
#' 
#' re <- "(qu|[b-df-hj-np-tv-z]*)([a-z]+)"
#' rewrite <- "\\2\\1ay"
#' s <- "the quick brown fox jumps over the lazy dogs."
#' expected <- "ethay quick brown fox jumps over the lazy dogs."
#' res <- re2_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "\\w+"
#' rewrite <- "\\0-NOSPAM"
#' s <- "abcd.efghi@google.com"
#' expected <- "abcd-NOSPAM.efghi@google.com"
#' res <- re2_replace(s, re, rewrite)
#' stopifnot(res == expected)
#'   
#' re <- "a.*a"
#' rewrite <- "(\\0)"
#' s <- "aba\naba"
#' expected <- "(aba)\naba"
#' res <- re2_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "b"
#' rewrite <- "bb"
#' s <- "ababababab"
#' expected <- "abbabababab"
#' res <- re2_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "b+"
#' rewrite <- "bb"
#' s <- "bbbbbb"
#' expected <- "bb"
#' res <- re2_replace(s, re, rewrite)
#' stopifnot(res == expected)
#' 
#' re <- "b*"
#' rewrite <- "bb"
#' s <- c("bbbbbb", "aaaaa")
#' expected <- c("bb", "bbaaaaa")
#' res <- re2_replace(s, re, rewrite)
#' stopifnot(res == expected)
#'      
#' @seealso \code{\link{re2_re2}}, \link{re2_syntax},
#'   \code{\link{re2_global_replace}},
#'   \code{\link{re2_match}}, \code{\link{re2_extract}}.
re2_replace <- function(text, pattern, rewrite, ...) {
    more_options <- list(...)
    .Call(`_re2_re2_replace`, text, pattern, rewrite, more_options)
}

